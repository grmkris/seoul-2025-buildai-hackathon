import type { db } from "@/server/db/db";
import type { Message } from "ai";
import { and, desc, eq, sql } from "drizzle-orm";
import {
  type ConversationId,
  MessageId,
  type UserId,
} from "@/server/db/typeid";
import { z } from "zod";
import { conversationsTable, messagesTable } from "../db/schema";

// Simplified options, only requiring db and conversationId
export interface SimpleChatHistoryServiceOptions {
  db: db;
  conversationId: ConversationId;
  userId: UserId;
}

export type ChatHistoryService = {
  addUserMessage: (message: Message) => Promise<Message>;
  addAgentMessages: (messages: Message[]) => Promise<Message[]>;
  getConversationMessages: () => Promise<Message[]>;
};

// Adding implementation for ChatHistoryService
export const createDrizzleChatHistoryService = (
  options: SimpleChatHistoryServiceOptions,
): ChatHistoryService => {
  const { conversationId, db, userId } = options;

  return {
    addUserMessage: async (message: Message): Promise<Message> => {
      // Store the user message
      const userMessage = await db
        .insert(messagesTable)
        .values({
          id: MessageId.parse(message.id), // it is important that we use the ID generated by the ai client, so that we are consistent
          message,
          conversationId,
          createdAt: z.coerce.date().parse(message.createdAt),
          createdBy: userId,
        })
        .returning();

      // Update the conversation's updatedAt
      await db
        .update(conversationsTable)
        .set({
          updatedAt: new Date(),
        })
        .where(eq(conversationsTable.id, conversationId));

      if (!userMessage[0]?.message) {
        throw new Error("Message not sent");
      }

      return userMessage[0].message;
    },

    // agent messages are streamed into the db, so we want to update and on conflict do update with the latest message
    addAgentMessages: async (agentMessages: Message[]): Promise<Message[]> => {
      if (agentMessages.length === 0) return [];
      // insert messages with incrementing timestamps to preserve order
      const messagesToInsert = agentMessages.map((message: Message) => ({
        id: MessageId.parse(message.id), // it is important that we use the ID generated by the ai client, so that we are consistent
        message,
        conversationId,
        createdAt: z.coerce.date().parse(message.createdAt),
        createdBy: userId,
      }));

      await db
        .insert(messagesTable)
        .values(messagesToInsert)
        .onConflictDoUpdate({
          target: [messagesTable.id],
          set: {
            message: sql.raw("excluded.message"),
          },
        });

      return agentMessages;
    },

    getConversationMessages: async (): Promise<Message[]> => {
      const conversationMessages = await db.query.conversationsTable.findFirst({
        where: and(eq(conversationsTable.id, conversationId)),
        with: {
          messages: true,
        },
        orderBy: desc(messagesTable.createdAt),
      });

      if (!conversationMessages) {
        throw new Error("Conversation not found");
      }

      return conversationMessages.messages.map((m) => m.message as Message);
    },
  };
};
