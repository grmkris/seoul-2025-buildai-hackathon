import type { db } from "@/db/db";
import { conversations, messages } from "@/db/schema/chat/chat.db";
import type { Message as CoreMessage } from "ai";
import { and, eq, sql } from "drizzle-orm";
import {
  type ConversationId,
  MessageId,
  typeIdGenerator,
  type WorkspaceId,
} from "typeid";
import { z } from "zod";

// Define missing types
export interface ChatHistoryServiceOptions {
  conversationId: ConversationId;
  workspaceId: WorkspaceId;
}

export interface ChatHistoryService {
  addUserMessage: (message: CoreMessage) => Promise<CoreMessage>;
  addAgentMessages: (agentMessages: CoreMessage[]) => Promise<CoreMessage[]>;
  getConversationMessages: () => Promise<CoreMessage[]>;
}

// Adding implementation for ChatHistoryService
export const createChatHistoryService = (
  options: ChatHistoryServiceOptions & { db: db },
): ChatHistoryService => {
  const { conversationId, workspaceId, db } = options;

  return {
    addUserMessage: async (message: CoreMessage) => {
      // Store the user message
      const userMessage = await db
        .insert(messages)
        .values({
          id: MessageId.parse(message.id), // it is important that we use the ID generated by the ai client, so that we are consistent
          message,
          conversationId,
          workspaceId,
          createdBy: typeIdGenerator('member'), // TODO: change to userID
          updatedBy: typeIdGenerator('member'), // TODO: change to userID
          createdAt: z.coerce.date().parse(message.createdAt),
        })
        .returning();

      // Update the conversation's updatedAt
      await db
        .update(conversations)
        .set({
          updatedAt: new Date(),
          updatedBy: typeIdGenerator('member'), // TODO: change to userID
        })
        .where(eq(conversations.id, conversationId));

      if (!userMessage[0]?.message) {
        throw new Error("Message not sent");
      }

      return userMessage[0].message;
    },

    // agent messages are streamed into the db, so we want to update and on conflict do update with the latest message
    addAgentMessages: async (agentMessages: CoreMessage[]) => {
      if (agentMessages.length === 0) return [];
      // insert messages with incrementing timestamps to preserve order
      const messagesToInsert = agentMessages.map((message: CoreMessage) => ({
        id: MessageId.parse(message.id), // it is important that we use the ID generated by the ai client, so that we are consistent
        message,
        conversationId,
        workspaceId,
        createdAt: z.coerce.date().parse(message.createdAt),
        createdBy: typeIdGenerator('member'), // TODO: change to userID
        updatedBy: typeIdGenerator('member'), // TODO: change to userID
      }));

      await db
        .insert(messages)
        .values(messagesToInsert)
        .onConflictDoUpdate({
          target: [messages.id],
          set: {
            message: sql.raw("excluded.message"),
          },
        });

      return agentMessages;
    },

    getConversationMessages: async (): Promise<CoreMessage[]> => {
      const conversationMessages = await db.query.conversations.findFirst({
        where: and(
          eq(conversations.id, conversationId),
          eq(conversations.workspaceId, workspaceId),
        ),
        with: {
          messages: true,
        },
      });

      if (!conversationMessages) {
        throw new Error("Conversation not found");
      }

      // Assuming SelectMessage['message'] is compatible with CoreMessage
      // If not, a transformation might be needed here.
      return conversationMessages.messages.map((m) => m.message);
    },
  };
};
